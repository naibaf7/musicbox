

import sys, os, argparse, math

import numpy as np
import mido
from mido import MidiFile

from scipy.io import wavfile

from os import listdir
from os.path import isfile, join



def main():

    path = os.path.dirname(os.path.abspath(__file__))

    pa = argparse.ArgumentParser()
    
    pa.add_argument('--sample', type = str, nargs = 1, default = ['p1.wav'])
    # A sample to take the attack from
    
    pa.add_argument('--melodies', type = str, nargs = '+', default = None)
    # List of MIDI melodies to convert
    
    pa.add_argument('--speed', type = float, nargs = '+', default = None)
    # Speed factor for melodies
    
    pa.add_argument('--outfile', type = str, nargs = 1, default = ['converted_melodies/music_data.h'])
    # Output header file to include for arduino
    
    pa.add_argument('--synthout', type = str, nargs = 1, default = ['converted_melodies/'])
    # Path for the created synthesized melodies (MIDI x SAMPLE)
    
    pa.add_argument('--sample_rate', type = int, nargs = 1, default = [22000])
    # Sampling rate
    
    pa.add_argument('--interrupt_ticks', type = int, nargs = 1, default = [150])
    # Interrupts per tick
    
    pa.add_argument('--sustain', type = int, nargs = 1, default = [128])
    # Sustain length
    
    pa.add_argument('--envelope', type = int, nargs = 1, default = [1024])
    # Envelope length
    
    pa.add_argument('--envelope_exp', type = float, nargs = 1, default = [199.0])
    # Envelope exponential factor
    
    pa.add_argument('--pot', type = int, nargs = 1, default = [8])
    # The number of binary digits to the right of the fixed point decimal point
    
    pa.add_argument('--reference_note_number', type = int, nargs = 1, default = [69])
    
    pa.add_argument('--min_note_number', type = int, nargs = 1, default = [0])
    
    pa.add_argument('--max_note_number', type = int, nargs = 1, default = [127])
    
    pa.add_argument('--reference_note_freq', type = int, nargs = 1, default = [440])
    
    pa.add_argument('--notes_per_octave', type = int, nargs = 1, default = [12])
    
    pa.add_argument('--midi_key_offset', type = int, nargs = 1, default = [14])
    # Offset to change sound pitch
    
    pa.add_argument('--generators', type = int, nargs = 1, default = [3])
    # Max simultaneous notes
    
    args = pa.parse_args()

    melody_files = []

    if args.melodies == None:
        melody_files = [f for f in listdir(path + '/melodies/') if isfile(join(path + '/melodies/', f)) and f.endswith('.mid')]
    else:
        melody_files = [melody + '.mid' for melody in args.melodies if isfile(path + '/melodies/' + melody + '.mid')]
        

    # Load and convert sample (attack)
    sample_fs, sample_data = wavfile.read(path + '/sample/' + args.sample[0])
    
    fundamental_frequency = float(args.sample_rate[0]) / float(args.sustain[0])
    
    output = str()
    
    output += '// Created using create_music_data.py\n'
    output += '// Autogenerated file, do not edit.\n\n\n'
    
    output += '#define NUMBER_OF_SONGS {0}\n'.format(len(melody_files))
    output += '#define ATTACK_LENGTH {0}\n'.format(len(sample_data))
    output += '#define SUSTAIN_LENGTH {0}\n'.format(args.sustain[0])
    output += '#define SAMPLE_RATE {0}\n'.format(args.sample_rate[0])
    output += '#define POT {0}\n'.format(args.pot[0])
    output += '#define WAVETABLE_LENGTH {0}\n'.format(len(sample_data) + args.sustain[0])
    output += '#define NUMBER_OF_GENERATORS {0}\n'.format(args.generators[0])
    output += '#define MIDI_KEY_OFFSET {0}\n'.format(args.midi_key_offset[0])
    output += '#define INTERRUPTS_PER_TICK {0}\n'.format(args.interrupt_ticks[0])
    output += '\n\n'
    
    output += 'const PROGMEM int8_t waveTableData [] = {\n  '
    # Attack data
    output += '// Attack\n  '
    for i in range(len(sample_data)):
        if i > 0 and i % 16 == 0 and i < len(sample_data) - 1:
            output += '\n  '
        output += str(int(round(sample_data[i] / 256.0))) + ', '

            
    # Sustain data
    output += '\n\n  // Sustain\n  '
    for i in range(args.sustain[0]):
        if i > 0 and i % 16 == 0 and i < args.sustain[0] - 1:
            output += '\n  '  
        output += str(int(round(127.0 * math.sin(2.0 * np.pi * float(i) / float(args.sustain[0]))))) + \
                  (', ' if i < args.sustain[0] - 1 else '')

    output += '\n};\n\n\n'
    
    output += 'uint16_t midiPitchData [] = {\n  '
    num_notes = args.max_note_number[0] - args.min_note_number[0] + 1
    for i in range(num_notes):
        if i > 0 and i % 16 == 0 and i < num_notes - 1:
            output += '\n  '
        note_number = args.min_note_number[0] + i
        offset = float(note_number - args.reference_note_number[0]) / float(args.notes_per_octave[0])
        note_freq = args.reference_note_freq[0] * math.pow(2.0, offset)
        note_number = int(round((1 << args.pot[0]) * note_freq / fundamental_frequency))
        output += str(note_number) + (', ' if i < num_notes - 1 else '')
    # Midi pitch data
    output += '\n};\n\n\n'

    
    output += 'const PROGMEM uint8_t envelopeData [] = {\n  '
    # Envelope data (decay)
    for i in range(args.envelope[0]):
        if i > 0 and i % 16 == 0 and i < args.envelope[0] - 1:
            output += '\n  '
        value = int(round((1 << args.pot[0]) * math.exp(-i / args.envelope_exp[0]))) - 1
        output += str(value) + (', ' if i < args.envelope[0] - 1 else '')
    
    output += '\n};\n\n\n'      
        
    # Sound data
    melody_index = 0
    for midi_melody_file, melody_file in zip([MidiFile(path + '/melodies/' + melody_file) for melody_file in melody_files], melody_files):
    
        speed = 1.0
        if args.speed is not None and args.speed[min(melody_index, len(args.speed) - 1)] is not None:
            speed = args.speed[min(melody_index, len(args.speed) - 1)]
    
        note_events = []
    
        tick_sum = 10
        # Start first note at 10 ticks
      
        for message in midi_melody_file:
            if message.type == 'note_on':
                # note_on marks a new attack on the glockenspiel
                tick_sum += int(float(args.sample_rate[0]) / float(args.interrupt_ticks[0]) * message.time * 1.0 / speed)
                if tick_sum > 65535:
                    # Melody exceedes allowed length
                    break
                if message.velocity > 0:
                    note_events.append((tick_sum, message.note))
              
            if message.type == 'note_off':
                tick_sum += int(float(args.sample_rate[0]) / float(args.interrupt_ticks[0]) * message.time * 1.0 / speed)
              
        note_events.append((0, 0))
        # End of melody marker

        output += '// ' + melody_file + '\n'
        output += 'const PROGMEM uint16_t song' + str(melody_index) + 'Data [] = {\n  '
        for i in range(len(note_events)):
            if i > 0 and i % 16 == 0 and i < len(note_events) - 1:
                output += '\n  '
            output += str(note_events[i][0]) + ', ' + str(note_events[i][1]) + (', ' if i < len(note_events) - 1 else '')

        output += '\n};\n\n\n'
        melody_index += 1
        
    # Write metadata
    
    output += 'const uint16_t* getSongDataAddress(int32_t index) {\n'
    output += '  switch(index % NUMBER_OF_SONGS) {\n'
    for i in range(len(melody_files)):
      output += '    case ' + str(i) + ':\n'
      output += '      return song' + str(i) + 'Data;\n'
    output += '  }\n'
    output += '}\n\n\n'
      
    # Convert sound data to samples
    
    
    
    os.makedirs(os.path.dirname(path + '/' + args.outfile[0]), exist_ok = True)
    
    with open(path + '/' + args.outfile[0], 'w') as outfile:
        outfile.write(output)

if __name__ == '__main__':
    main()
